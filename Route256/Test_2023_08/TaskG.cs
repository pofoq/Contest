using Route256.Common;

namespace Route256.Test_2023_08
{
    internal class TaskG : ITask
    {
        public void Run()
        {
            var arr = Console.ReadLine()!.Split(' ').Select(s => int.Parse(s)).ToArray();
            var userCount = arr[0]; // n
            var friendPairCount = arr[1];// m

            var users = Enumerable.Range(1, userCount).ToDictionary(i => i, i => new User(i));

            for (var i = 0; i < friendPairCount; i++)
            {
                arr = Console.ReadLine()!.Split(' ').Select(s => int.Parse(s)).ToArray();
                users[arr[0]].Friends.Add(users[arr[1]]);
                users[arr[1]].Friends.Add(users[arr[0]]);
            }

            foreach (var user in users.Values)
            {
                var recommended = GetRecommendedFriends(user);
                if (recommended.Count == 0)
                {
                    Console.WriteLine(0);
                }
                else
                {
                    var max = recommended.Max(i => i.Value);
                    foreach (var r in recommended)
                    {
                        if (r.Value == max)
                        {
                            Console.Write($"{r.Key.Id} ");
                        }
                    }
                    Console.WriteLine();
                }
            }
        }

        static SortedDictionary<User, int> GetRecommendedFriends(User user)
        {
            var maybeFriend = new SortedDictionary<User, int>();

            if (user.Friends.Count == 0)
            {
                return maybeFriend;
            }

            foreach (var friend in user.Friends)
            {
                if (friend.Friends.Count < 2)
                {
                    continue;
                }

                foreach (var candidate in friend.Friends)
                {
                    if (candidate.Equals(user) || candidate.Friends.Contains(user))
                    {
                        continue;
                    }
                    if (maybeFriend.ContainsKey(candidate))
                    {
                        maybeFriend[candidate] = maybeFriend[candidate] + 1;
                    }
                    else
                    {
                        maybeFriend.Add(candidate, 1);
                    }
                }
            }

            return maybeFriend;
        }

        public readonly struct User : IComparer<User>, IComparable<User>
        {
            public int Id { get; }
            public HashSet<User> Friends { get; }

            public User(int id)
            {
                Id = id;
                Friends = new HashSet<User>();
            }
            public readonly bool Equals(User? obj)
            {
                return Id.Equals(obj?.Id);
            }

            public override readonly string ToString()
            {
                return Id.ToString();
            }

            int IComparer<User>.Compare(User x, User y)
            {
                return x.Id < y.Id ? -1 : 1;
            }

            int IComparable<User>.CompareTo(User other)
            {
                return Id.CompareTo(other.Id);
            }
        }
    }
}
/*
 G. Возможные друзья (20 баллов)
ограничение по времени на тест3 секунды
ограничение по памяти на тест512 мегабайт
вводстандартный ввод
выводстандартный вывод
Во многих социальных сетях у пользователей есть возможность указать других пользователей как своих друзей. Помимо этого, часто существует система рекомендации друзей, которая показывает пользователям людей, с которыми они знакомы косвенно (через кого-то из своих друзей), и предлагает добавить этих людей в список друзей. Вам предстоит разработать систему рекомендации друзей.

В интересующей нас социальной сети n
 пользователей, каждому из которых присвоен уникальный id от 1
 до n
. У каждого пользователя этой сети не более 5
 друзей. Очевидно, ни один пользователь не является другом самому себе, и если пользователь x
 в списке друзей у пользователя y
, то и пользователь y
 входит в список друзей пользователя x
.

Опишем, как должен формироваться список возможных друзей для каждого пользователя. Для пользователя x
 в список должны входить такие пользователи y
, что:

y
 не является другом x
 и не совпадает с x
;
у пользователя y
 и у пользователя x
 есть хотя бы один общий друг;
не существует такого пользователя y′
, который удовлетворяет первым двум ограничениям, и у которого строго больше общих друзей с x
, чем у y
 с x
.
Иными словами, в список возможных друзей пользователя x
 входят все такие пользователи, не являющиеся его друзьями, для которых количество общих друзей с x
 максимально. Обратите внимание, что список возможных друзей может быть пустым.

Вы должны написать программу, которая по заданной структуре социальной сети формирует списки возможных друзей для всех пользователей сети.

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.

Входные данные
В первой строке заданы два целых числа n
 и m
 (2≤n≤50000
; 0≤m≤min(n(n−1)2,5n2)
) — количество пользователей и количество пар друзей, соответственно.

Далее следуют m
 строк, в каждой из которых заданы два целых числа xi
 и yi
 (1≤xi,yi≤n
; xi≠yi
) — очередная пара друзей в социальной сети. Каждая пара друзей задается не более одного раза; у каждого пользователя не более 5
 друзей.

Выходные данные
Для каждого пользователя от 1
 до n
 выведите в отдельной строке список его возможных друзей в следующем формате:

если список возможных друзей пуст, выведите одно целое число 0
;
иначе выведите id возможных друзей пользователя в возрастающем порядке.
Примеры
входные данныеСкопировать
8 6
4 3
3 1
1 2
2 4
2 5
6 8
выходные данныеСкопировать
4
3
2
1
1 4
0
0
0
входные данныеСкопировать
8 10
1 2
1 3
1 4
4 3
3 2
2 4
1 8
5 6
7 6
5 7
выходные данныеСкопировать
0
8
8
8
0
0
0
2 3 4
Примечание
Рассмотрим первый пример из условия.

Для начала сформируем списки друзей всех пользователей:

друзья пользователя 1
: [2,3]
.
друзья пользователя 2
: [1,4,5]
.
друзья пользователя 3
: [1,4]
.
друзья пользователя 4
: [2,3]
.
друзья пользователя 5
: [2]
.
друзья пользователя 6
: [8]
.
друзья пользователя 7
: []
 (список друзей пуст).
друзья пользователя 8
: [6]
.
Рассмотрим, как формируются списки возможных друзей для некоторых пользователей.

У пользователя 1
 есть два пользователя, которые не являются его друзьями и с которыми у него есть хотя бы один общий друг: это пользователь 4
 (общие друзья 2
 и 3
) и пользователь 5
 (общий друг 2
). С пользователем 4
 общих друзей больше, поэтому в список возможных друзей попадает только он.

У пользователя 5
 есть два пользователя, которые не являются его друзьями и с которыми у него есть хотя бы один общий друг: это пользователь 1
 (общий друг 2
) и пользователь 4
 (общий друг 2
). Количество общих друзей одинаковое, поэтому оба этих пользователя попадают в список возможных друзей.

У пользователя 7
 вообще нет друзей, поэтому ни один пользователь не удовлетворяет требованиям списка возможных друзей.
*/